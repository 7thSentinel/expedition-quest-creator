import {
  NEW_QUEST, LOAD_QUEST, SAVE_QUEST, DELETE_QUEST, DOWNLOAD_QUEST,
  ReceiveQuestLoadAction,
  RequestQuestSaveAction, ReceiveQuestSaveAction,
  RequestQuestPublishAction, ReceiveQuestPublishAction,
  RequestQuestUnpublishAction, ReceiveQuestUnpublishAction,
} from './ActionTypes'
import {QuestType, ShareType} from '../reducers/StateTypes'

import {setDialog} from './dialogs'
import {pushError, pushHTTPError} from '../error'
import {realtimeUtils} from '../auth'

// Loaded on index.html
declare var window: any;

var toXML: any = (require('../../translation/to_xml') as any).toXML;

function receiveQuestLoad(quest: QuestType ): ReceiveQuestLoadAction {
  return {type: 'RECEIVE_QUEST_LOAD', quest};
}

const VERSION = "Engine V1";

const QUEST_DOCUMENT_HEADER = `This quest was automatically generated by the Expedition Quest Creator at http://expedition-quest-ide.appspot.com.
To make changes: right-click the file in Drive, select "Open With" and choose "Expedition Quest Creator".\n\n` + VERSION + '\n\n';

const NEW_QUEST_TEMPLATE = `
# Quest Title
summary: Quest summary
author: Your Name
email: email@example.com
url: yoursite.com
minPlayers: 2
maxPlayers: 4
minTimeMinutes: 20
maxTimeMinutes: 40

_Roleplay Title_

roleplay text

**end**
`;

function updateDriveFile(fileId: string, fileMetadata: any, text: string, callback: () => any) {
  const boundary = '-------314159265358979323846';
  const delimiter = "\r\n--" + boundary + "\r\n";
  const close_delim = "\r\n--" + boundary + "--";

  // TODO: Set quest title based on metadata

  text = QUEST_DOCUMENT_HEADER + text;
  var base64Data = btoa(text);
  var multipartRequestBody =
      delimiter +
      'Content-Type: application/json\r\n\r\n' +
      JSON.stringify(fileMetadata) +
      delimiter +
      'Content-Type: text/plain\r\n' +
      'Content-Transfer-Encoding: base64\r\n' +
      '\r\n' +
      base64Data +
      close_delim;

  var request = window.gapi.client.request({
      'path': '/upload/drive/v2/files/' + fileId,
      'method': 'PUT',
      'params': {'uploadType': 'multipart', 'alt': 'json'},
      'headers': {
        'Content-Type': 'multipart/mixed; boundary="' + boundary + '"'
      },
      'body': multipartRequestBody});
  request.execute(callback);
}

export function loadQuestFromURL(dispatch: Redux.Dispatch<any>) {
  // TODO: Accept URLs of the following format (i.e. from Drive "open with" user interaction):
  //?state=%7B"ids":%5B"0BzrQOdaJcH9MeDhic2ctdFNSdjg"%5D,"action":"open","userId":"106667818352266772866"%7D

  // When user is logged in, create a new quest if there's not one already.
  if (window.location.hash) {
    loadQuest(dispatch, window.location.hash.substr(1));
  } else {
    loadQuest(dispatch, null);
  }
}


export function newQuest(dispatch: any) {
  var insertHash = {
    'resource': {
      mimeType: "text/plain",
      title: "New Expedition Quest",
      description: "Created with the Expedition Quest Creator",
    }
  };
  window.gapi.client.drive.files.insert(insertHash).execute(function(createResponse: {id: string}) {
    updateDriveFile(createResponse.id, {}, "", function() {
      loadQuest(dispatch, createResponse.id);
    });
  });
}

export function loadQuest(dispatch: any, docid?: string) {
  if (docid === null) {
    console.log("No docid, creating new quest");
    return newQuest(dispatch);
  }

  realtimeUtils.load(docid, function(doc: any) {
    window.location.hash=docid;
    var md = doc.getModel().getRoot().get('markdown');
    dispatch(receiveQuestLoad({id: docid, mdRealtime: md}));
  },
  function(model: any) {
    var string = model.createString();
    string.setText(NEW_QUEST_TEMPLATE);
    model.getRoot().set('markdown', string);
  });
}

export function publishQuest(quest: QuestType): ((dispatch: Redux.Dispatch<any>)=>any) {
  return (dispatch: Redux.Dispatch<any>): any => {
    var data = quest.mdRealtime.getText();
    try {
      data = toXML(data, false);
    } catch (e) {
      pushError(e);
      dispatch(setDialog('ERROR', true));
      return;
    }

    dispatch({type: 'REQUEST_QUEST_PUBLISH', quest} as RequestQuestPublishAction);
    return $.post("/publish/" + quest.id, data, function(result_quest_id: string) {
      dispatch({type: 'RECEIVE_QUEST_PUBLISH', quest} as ReceiveQuestPublishAction);
    }).fail(pushHTTPError);
  }
}

export function saveQuest(quest: QuestType): ((dispatch: Redux.Dispatch<any>)=>any) {
  return (dispatch: Redux.Dispatch<any>): any => {
    dispatch({type: 'REQUEST_QUEST_SAVE', quest} as RequestQuestSaveAction);
    updateDriveFile(quest.id, {}, quest.mdRealtime.getText(), function() {
      dispatch({type: 'RECEIVE_QUEST_SAVE', quest} as ReceiveQuestSaveAction);
    });
  };
}

export function unpublishQuest(quest: QuestType): ((dispatch: Redux.Dispatch<any>)=>any) {
  return (dispatch: Redux.Dispatch<any>): any => {
    dispatch({type: 'REQUEST_QUEST_UNPUBLISH', quest} as RequestQuestUnpublishAction);
    return $.post("/unpublish/" + quest.id, function(result_quest_id: string) {
      dispatch({type: 'RECEIVE_QUEST_UNPUBLISH', quest} as ReceiveQuestUnpublishAction);
    }).fail(pushHTTPError);
  };
}